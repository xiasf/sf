关于此myphp文档：亦是文档，亦是日志，亦是心得，亦是笔记……

【关于myphp】
	一开始呢，并不是想做一个通用的框架，只是想把开发模式及一些底层的东西定
下来，这样以后所有的项目都可以在这个基础上构建，但并不意味着这是一个非常全面
的框架（它本来就不是框架），本不喜欢太高度集成的东西。
	myphp最终的价值是体现在开发模式上面的，而不是能让你轻松的就能快速构建应用，好吧，
你已经想到了thinkphp，我承认它和tp长得有点像，它确实借鉴了tp的一些比较好的东西，但也意识到tp应用
的局限性，一个东西想做的大而全势必会臃肿，应用是活的，一个框架怎么可能实现没有性能损
耗而适配所有应用呢（php创始人也说了，框架怎么可能满足所有应用呢，就像只造一辆汽车怎么可能满足所有人呢），显然这中间的开销被分流到框架上面去了，事实上我们说到的用框架就不能避免性能损耗问题就在于此了。
	我们的myphp显然不是步这个后尘的，如果你非要叫它框架，那就随便你吧，但我却更愿意把它当做是一种
开发模式（亦或是架构）来使用。
	myphp是简单的。简单意味着结构清晰，伸缩性强，对代码来说更是如此，优秀的代码不是看你写了多少多少行，用了多少高级函数，设计模式，而是看你的代码有多简洁，构思多么精巧，用最少的代码做更多的事才是最成功的代码，这就好像每个人都知道走最近的路到达目的地是最快的一样。追求极致就是对自己永远的苛求，不断的改变，最终努力趋于心中的完美。
	myphp，不是框架一个更具说明力的就是，你可以随意更改它，它的一切都可以根据需求进行更改，只要确保
你的更改不会出错就可以，而对于真正框架是不允许你这么做吧，你只能准备自己的文件供框架调用，但myphp显然不是这样的
它的亮点就是它不是框架，它是自由的可自定义的，它能给你的只是开发的模式，其它的随你的喜好，如果真要问它，它遵循的是什么，那么我只能回答的是；在任何时候myphp首先考虑的是安全和性能，这点是myphp的灵魂，我这么说你懂了吗？

————————————————————————————————————————————————————————————————————————)


【网页程序概念】
+————————————————————————————————————————————————————————————(
网页是应用程序吗？
是，但又不像。又说不出是哪里不对劲。
如果是，它是怎么运行的呢，我们常见程序双击打开就能运行，但网页程序怎么双击呢？
我们不可能像传统的方式那样打开应用程序了，打开网页用的是http协议，所以“打开”
网页就是发送http请求。网页还分为静态网页和动态网页。静态网页本质上算不上程序，为了区别这些，
我们将请求的对象分成两种：
动态请求：响应请求的是php；
静态请求：请求的是服务上的一个静态资源。
如果是一个动态请求的话那么这个被请求文件（.php）就会在服务器上运行一下，
这样就运行了程序，所以网页也是应用程序，只是应用及使用场景与传统应用程序不一样罢了。
)————————————————————————————————————————————————————————————+


【myphp进程概念】
+————————————————————————————————————————————————————————(
在MVC思想中http的每个请求都可看做一个module和action（模块_方法名）
所以每个请求都是唯一的即mod_act唯一，如果我们把一个mod_act看做是一个进程的话，
那么这样我们每次请求就好像就是在运行一个进程一样。
我们缓存的进程文件就为实现某个功能而需要的文件的合集。
（相当于tp的~runtime只不过我们将它做细了，~runtime就像我们的去除了预编译指令部分的进程基文件，而我们的进程就是在此上增加了mod_act动态文件的）
并不能以为一个浏览器页面对应的就是一个进程，因为这个页面可能有各个模块
在运行，即一个页面并不代表只有一个动态请求对吧，我这么说，你懂了吗？

（要做到动态加载，代码重用，就肯定需要自动加载函数，tp的__autoload()确实很强大，但这会在运行过程中带来IO，给php带来更多的压力，性能损耗，可见~runtime.php的想法很美好，但无赖却不能完全实现，完全消除IO，但没有myphp的进程概念时这又是无法做到和避免的，这是myphp最大的亮点之一，进程文件不再需要加载任何的文件，注意是任何文件哦，每一个进程都是完整（确保只包含会用到的部分，绝不会多包含一个字符，珍惜每一byte的资源，内存，真正做到按需加载）的，这些经过高效编译的进程文件将给系统带来最大的性能提升。通过消除IO，“预编译”来提高运行性能是进程信奉的最主要也是最重要的思想。）

（ps：现在不那么简单了，引入了一个do：ACTION=act=do，详情请参考“【ACTION与do】”）
（ps：myphp架构现已升级原模块升级为控制器，所以现在的进程应该是C_A了，但习惯上我们还是写mod_act也行，只要知道它是控制器_操作就可以了）

ps：myphp进程的两大核心：
1：不论何时进程文件已全面作好准备，时刻迎接挑战，不再需要加载任何文件。
2：为了提高进程的运行性能，按需加载，按需使用，只包含要用到的，不包含用不到的，不多带一个字符，珍惜每一byte的资源，内存，这就是我们永远的追求——不论何时，安全和性能都是myphp要优先考虑的。
【两大核心相互有关联（可以用一句不太恰当的话来形容它们“一方面我们要防止出现不完整进程，另一方面又要防止进程过载”），都是为了最大限度的提高进程的运行性能。】

进程生成原理：我们根据路由运行后（不关心运行过程的一些细节），会有一个文件加载列表的，这个文件加载列表是运行过程中加载文件时产生的，也就是说它的顺序跟运行时是一致的，因为它根本就是它来的嘛，而我们生成进程实际就是stup.php的最后myimport('cache');只有走运行时文件且调试关闭时才会生成进程，为什么在这个最后执行这条语句，原因很简单嘛，只有根据路由运行了才能确定完整的文件列表嘛，但是现在有一个问题，我们运行可能有很多情况，可能会有一些“选择”导致某次可能不会加载某文件，而某次有需要加载某文件，但上次却生成了那个进程，这样就导致出现不完整进程，当然后来我们想办法暂时解决了这个问题，虽然好像不是什么好办法，但却是唯一的办法，看样子现在进程也没什么问题，但是就在今天，我们突然意识到还有一种情况会让我们的会“阻碍”我们的进程，那就是运行有可能用exit;这样的语句，那么此时脚本就会结束，注意这还是在控制器的操作中结束的，还没有到myimport('cache');这儿来呢，所以这种情况就会导致我们根本就生成不了进程，其实这种情况不生成进程也好，这跟不完整进程的概念不一样，没有进程还好说，要是有但不完整那就糟了。虽然说是这样说，但是你不生成进程，你干啥呢，别人都生成，就你不生成，你把自己当什么呢，你认为你跟别人不一样吗？于是各种质疑就来了，看来不能搞特殊，不能特立独行，那就就算结束脚本也要生成进程吧，其实想做到也很容易，将myimport('cache');放到控制器析构里面不就可以了吗，对，是可以，这很容易，但不管怎样我们还是要保证不出现不完整进程啊，以前我们是要在“选择”前就提前加载，那么现在还要在可能结束脚本前就提前加载，其实这也是选择嘛，哈哈。
待续……2014-5-24 0:00:29
)————————————————————————————————————————————————————————+


【myphp模型说明】
+————————————————————————————————————————————————————————(
我们原以为应该要模型是基于表的，每张表对应一个模型，或者是基于功能模块的模型，我们曾经嘲笑过基于基于表的模型，讽刺它太死板了，为此我们甚至于想一举推翻它建立前所未有的基于功能模块的模型。现在看来这想法多么的可笑，也太小看tp了，既然能我们认识到严格古板保守的MVC的缺陷，别人难道都是傻瓜，它们早就在使用更为灵活的MVC开发了，却老是再讲着必须严格分层分离，还有诸如此类的“解决实体与对象之间的阻抗”等等芸芸，所以才导致了我们不能灵活的看待MVC，下面让我们从tp的模型应用中来体会灵活的MVC开发模式：
应用（使用）模型就是实例化模型：

1：实例化基础模型类：
$User = new Model('User')  等价于   $user = M('User');

2：实例化（基础）空模型类：
$Model = new = Model()		等价于		$Model = M();

3：实例化通用模型类：
$User = new CommonModel('User')		等价于		$User = M('User', 'CommonModel')
通用模型也在项目目录的模型文件夹中和自定义模型放在一起，也和自定义模型一样都要继承自基础模型类，通用模型一般与基础模型配合使用。那自定义模型可以继承通用模型么？

4：实例化自定义模型类：
$User = new UserModel()		等价于		$User = D('User');
可以看到它没有传递表名，so，这还不简单啊，你不是早说过它是基于表的模型吗，那么它当然知道自己对应的是哪个表啊


不看不知道，一看吓一跳，原来tp这么不老实了，我们原先所理解的基于表的模型其实就是它自定义模型类，哈哈，那真的有没有基于功能模块的模型呢，没错，别人早就想出来了，看，不就是通用模型类哈（关联模型）。
)————————————————————————————————————————————————————————+


【myphp提醒】
+————————————————————————————————————————————————————————(
程序中空格的表示请注意下：
我们的编译格式化太强大了，杀伤力太大也有烦劳，比如它可能干掉你的空格，但只要我们这样对待空格就没有问题：
1：程序中想要输出与下面关键字挨着的空格请用&nbsp;代替；
2：正则中请用[ ]{n,m}
模板中它就不管了
$content = preg_replace('/\s*(\(|\)|;|\{|\}|<|>|\?|,|:|!|\.|\+|-|\*|\/|%|=|&|\|)\s*/', '\1', $content);（现已升级）

由于正则的一些原应，所以要尽量的不要使用#注释哦，因为这可能回合css样式冲突。
)————————————————————————————————————————————————————————+


【myphp代码如诗——心灵美，代码也要美！】
+————————————————————————————————————————————————————————(
myphp一定是：代码如诗。极具美感，理性的代码，准确的说是结构清晰，代码如诗的开发模式将使所有项目得益，所有项目都能感受到这种代码如诗的魅力，注意美感的代码并不会带来性能上的损耗，相反它的好处是显而易见的，它使代码更加规范，增强阅读性，和维护性，最关键的是代码如诗是追求极致怎能少得了的呢。
（在规范代码方面其实我们的编辑器已经给了我们许多的提示了，很多辅助比如分割线，标示线等都是不错的辅助）
)————————————————————————————————————————————————————————+


----------------------------------------------------------------------------------
【myphp架构·项目部署（开发模式）】
myphp全新架构：wroot/项目/应用/模块 		应用/模块/控制器/方法/子方法/子方法n……	这种设计可以满足任何需求，堪称完美，至赞！
（现已升级：原分组->模块，原模块->控制器）严格使用标准的m，c，a嫌参数陈长，怎么会呢，还要入口绑定模块，或模块中使用入口文件并绑定模块。对于应用的单一入口，如果想要访问非默认的模块，那参数确实是长，但一般怎么会放着模块入口不用呢，而且虽说参数长了点，但应用单一入口简直“我的地盘我做主”，访问各个模块简直无下限啊。
现在所讲的架构就只是包括：目录部署，域名部署
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tpl/模块/控制器/操作.html 	tpl/user/message/send.html 	（模板编译缓存也是一样的）

/**
 *  这些语义很重要
 *	ORG：		项目公共文件夹，是指——应用们共用的
 *	APP_P：		应用公共文件夹，是指——模块们共用的（公共模块，可以算是应用目录下的一个特殊模块，不能直接访问）
 *  对于函数库文件，有四处：ORG，APP_P，相应模块下，系统函数库
 *  对于类库文件，也有四处：ORG，APP_P，相应模块下，系统函数库
 *  对于控制器类，模型类（自定义）文件，只有三处：ORG，APP_P，相应模块下
 */

 /**
  * 域名是绑定到项目目录的，不知道会不这会影响到$_SERVER['DOCUMENT_ROOT']的值。如果是，那么url部分可能要调整
  * 服务器web目录是web服务器软件设定的，域名是自己绑定的，此部署在具体情况中可做相应灵活的调整
  */

 wroot								// 【服务器web目录】
	 │
	 ├──musiccfan				  	// 【musiccfan项目】www.musiccfan.com，musiccfan.com直接绑定的目录
	 │			│
	 │			├──home 		  	// 【主站/主应用的（home模块）】（暴露在外面的都是主应用的模块，因为主应用没有应用文件夹）
	 │			│     │    
	 │			│  	  ├──common   	// 模块函数库文件夹
	 │			│     │    
	 │			│  	  ├──include   	// 模块类库文件夹
	 │			│     │
	 │			│  	  ├──lib
	 │			│  	  │	   ├──model
	 │			│  	  │	   ├──controller
	 │			│  	  │
	 │			│	  │
	 │			│	  ├──conf 		// home模块的配置文件夹
	 │			│  	  │	   ├──config.php
	 │			│  	  │	   ……
	 │			│  	  │	
	 │			│  	  ├──static
	 │			│  	  │	   ├──images
	 │			│  	  │	   ├──css
	 │			│  	  │	   ├──js
	 │			│
	 │			│
	 │			├──admin		  		// 【主站/主应用的（admin模块）】
	 │			│     │    
	 │			│  	  ├──common   		// 函数库文件夹
	 │			│     │    
	 │			│  	  ├──include   		// 模块类库文件夹
	 │			│     │
	 │			│  	  ├──lib      
	 │			│  	  │	   ├──model
	 │			│  	  │	   ├──action
	 │			│  	  │	
	 │			│	  ├──conf 			// admin模块的配置文件夹
	 │			│  	  │	   ├──config.php
	 │			│  	  │	   ……
	 │			│  	  │	
	 │			│  	  ├──static      
	 │			│  	  │	   ├──images
	 │			│  	  │	   ├──css
	 │			│  	  │	   ├──js
	 │			│	  │
	 │			│	  ├──index.php 		// 【主站/主应用（admin模块）入口，肯定绑定了模块的】（要是没绑定模块放在这里就没有任何意义了）
	 │			│
	 │			├──user （同上）
 	 │			│
 	 │			├──shop （同上）
	 │			│
	 │			├──data							// 应用资料文件夹
	 │			│	  ├──cache					// 应用缓存文件夹
	 │			│	  │      ├──mod_act			// 应用缓存进程文件夹
	 │			│	  │		 │	      ├──home	// home模块下的进程
	 │			│	  │		 │		  │		├──default  （这个default暂时取消了，实在不知道这样有什么意义，难道要多套进程？）
	 │			│	  │		 │		  │		│		 ├──index.index.php
	 │			│	  │		 │		  │		│		 ├──user.index.php
	 │			│	  │		 │		  │		│		 ……
	 │			│	  │		 │		  │		├──t2
	 │			│	  │		 │		  │		……
	 │			│	  │		 │		  │
	 │			│	  │		 │		  ├──admim	// 同上
	 │			│	  │		 │
	 │			│	  │		 │
	 │			│	  │		 ├──templates_c				// 应用模板编译缓存文件夹（这和模板部署是对应的）
	 │			│	  │					  ├──default	// 默认模板主题（ t……n其它模板主题）
	 │			│	  │		 			  │		   │
	 │			│	  │					  ├──t2	   │	
	 │			│	  │					  …… 	   │
	 │			│	  │					  		   ├──home			// home模块
	 │			│	  │					  		   │     ├──default			（没个模块也可以有多套模板的哦）
 	 │			│	  │					  		   │	 ├──t2    ├──index	// index控制器
 	 │			│	  │					  		   │     ……       │       ├──index.tpl.php	（操作名.tpl.php）
	 │			│	  │					  		   │	          │       ……				// 以模块，控制器为文件夹，操作（方法名）为文件名
	 │			│	  │					  		   │	  	 	  │	
	 │			│	  │					  		   │	  	 	  ├──page	 // page控制器
	 │			│	  │					  		   │	  		  │	    ├──index.tpl.php	（操作名.tpl.php） 	
	 │			│	  │					  		   │      	      │	    …… 
	 │			│	  │					  		   │	  		  ……
	 │			│	  │					  		   │	 
	 │			│	  │					  	       │	  
	 │			│	  │					  		   │				 
	 │			│	  │					  		   ├──admin	（同上）
	 │			│	  │					  		   ├──user  （同上）
 	 │			│	  │					  		   ├──public（同上，模块间共用模板（应用母版），我们觉得仅模块有母版还不够）
	 │			│	  │					  		   ……
	 │			│	  │
	 │			│	  ├──beifen	（备份一些重要的文件，我们不会提供管理备份文件的功能，当然你可以手动进行管理）
	 │			│	  │
	 │			│	  ├──temp
	 │			│	  │
	 │			│	  ├──uplod
	 │			│	  │
	 │			│	  …… 	（更多）
	 │			│
	 │			│
	 │			├──public	【应用公共目录】（这是本次架构设计中最惹人注目的明星了，但毫不忌讳的承认它模仿tp的公共模块/应用公共目录，但是tp会想到将模板放在这里吗，我们这个和tp是没法比的，等下你就知道它的厉害了）
	 │			│		│  
	 │			│		├──common		（应用公共函数库目录）
	 │			│		│  
	 │			│		├──include		（应用公共类库目录）
	 │			│		│  
	 │			│		├──model		（应用公共模型目录）
	 │			│		│
	 │			│		├──controller	（应用公共控制器目录）
	 │			│		│  
	 │			│		├──templates 	// 【应用模板文件夹】（这个就是亮点，就是完爆tp公共模块的前瞻性设计，将模板放在应用公共目录（模块们共用的）下面，这就暗示着对于整个应用这些模板是一个整体，对于模块又是相对独立的，但模块相互间调用彼此的模板又是那么的简单灵活，无节操，无下限的随意调用简直爽死了，这样设计显然是为了避免tp模板在模块中的分散，试想一下，要为应用开发一套模板，但是模板却在每个模块下面，那这不是在逗吗，我是要为整个应用开发整套模板的，现在这个问题就解决了，你可以为整个应用开发，也可以单独为某个模块开发一套，模块下的主题细分，现在就先不要了）
	 │			│		│		   ├──default
	 │			│		│		   ├──t2	├──home （当前应用home模块下的模板）
	 │			│		│		   ……   	│	  ├──default		（模块也可以有多套模板哈）
	 │			│		│		     		│	  ├──t2    ├──index	（index控制器）
	 │			│		│		     		│	  ……       │	  ├──index.html 	（操作名.html）
	 │			│		│		     		│			   │	  ……
	 │			│		│		   		  	│	  		   │		
	 │			│		│					│	  		   ├──page	（page控制器）	
	 │			│		│					│	  		   │     ├──index.html 	（操作名.html）
	 │			│		│					│	  		   │     ……
	 │			│		│					│	  		   ……
	 │			│		│					│	  			
	 │			│		│					│	  			
	 │			│		│					│	  			
	 │			│		│					│
	 │			│		│					├──admin	（同上）
	 │			│		│					├──user		（同上）
  	 │			│	  	│					├──public（同上，模块间共用模板（应用母版），我们觉得仅模块有母版还不够）
	 │			│		│					…… 			（更多模块）
	 │			│		│
	 │			│		├──static	（应用公共静态文件目录）
	 │			│				├──images
	 │			│				├──css
	 │			│				├──js
	 │			│
	 │			│
	 │			│
	 │			├──run	// 【超级进程池】（其实就是超级入口，但这是给系统用的，因为它们没有url结构，语义对用户不友好）
	 │			│
	 │			├──user.php 			// 【绑定了模块user的入口】
	 │			│
	 │			├──shour.php 			// 【超级入口，可以说是绑定了模块，控制器，操作的超级入口。】
	 │			│
	 │			├──index.php 			// 【主站入口】（准确的说是应用单一入口，对它的称赞有应用入口之母，进程之母等）
	 │			│
	 │			│
	 │			│
	 │			│
	 │			├──bbs				  	// 【社区（应用）】同上，主应用没有应用文件夹，但其他应用有 域名形式部署为：bbs.musiccfan.com
	 │ 			│
	 │ 			├──shop				// 【商城等应用】	域名形式部署为：shop.musiccfan.com
	 │ 			│
	 │ 			├──n……				// 【应用……】		xxx.musiccfan.com 	（当然，如果应用很大的可能应用们不在同一台服务器上）
	 │ 			│
	 │ 			├──ORG				// 【项目公共目录】
	 │ 			│	 ├──common		// 项目公共函数库文件夹
	 │ 			│	 ├──include		// 项目公共类库文件夹
	 │ 			│	 ├──model		// 项目公共模型文件夹
	 │ 			│	 ├──controller	// 项目公共控制器文件夹
	 │			│	 ├──static		// 项目公共静态文件存放文件夹
	 │			│			 ├──images
	 │			│			 ├──css
 	 │			│			 ├──js
	 │			│
	 │			│
	 │			├──myphp			// 【把系统放在项目这里，让它离开发更近一点嘛（本可放在wroot跟目录下公用），也使得系统自定义性增强，有更多自由空间（必要时可根据实际情况自定义、扩展定制系统），况且一个空间ip下放多个项目也不太可能（所以跨项目没有意义），项目大的话一个应用都可能要多个服务器呢，所以把myphp放wroot下共用没实际意义。】
	 │				   ├──common	// 【系统函数库文件夹】
	 │				   │
	 │				   ├──include	// 【系统类库文件夹】
	 │				   │	 
	 │				   ├──lib		// 【系统核心】
	 │				   │
	 │				   ├──static	// 【系统静态文件存储文件夹】（这个一般不需要，除非有什么js库收集的还可以）（但是为了友好等还是可以要的，比如出错提示等啊，但现在还没做得这么智能）
	 │				   │	   ├──images
	 │				   │	   ├──css
	 │				   │	   ├──js
	 │				   │
	 │				   ├──setup.php 	// 【系统入口/启动文件】
	 │
	 │
	 ├──mycms	// 【其它等项目】
	 │
	 ……			// 【项目……n】（当然很少有可能多个项目放在同一台服务器上面）


（以上是myphp的架构·项目开发模式，所有的开发将以它的规范为规则来进行开发，此架构适于所有项目开发，灵活多变，必要时可灵活使用。）
（其中一些文件夹是系统规定的，删除系统必将出错，一些是系统会自己创建的，如：templates_c就是系统规定的，templates_c/default/却是可以被删的。）

ps：项目部署实际就是myphp的部署，因为项目是按照myphp这种开发模式开发的，所以说项目的部署实际就是myphp的部署，当然这只是参考的部署方式，（实际中可能还受到域名，空间部署等影响）实际应用中可能还要根据实际情况进行灵活自由的部署，如将wroot直接改为项目目录等灵活的变动，只要遵循myphp的规范部署即可。

:) myphp不是框架，自由给你更多！
:) myphp是开发模式，或者说叫架构也可以，但它不想这样。
待续……2014-7-23 14:23:59

note：
	· 项目目录部署是从项目绝对目录开始的，只有确定了项目目录，其它目录都可以被确定了（主站/主应用有特殊性），只要能确定这点不论入口放在那里都是一样的，“单一入口，但并不是唯一的”，这是最好的证明了。而项目目录就在wroot下面。
	· 文件名中的"."代表此文件的作用及类型等，如：index.tpl.php代表它是一个模板编译文件，而"_"则表示此文件由什么什么构成或相关联，如mod_act.php
	· 主站的特殊性在于它没有应用名，难道它要跟项目名同名或者叫zhuzhan不成，所以它就暴露在项目中，没有应用目录的，同时请注意home可没有一点点前台的意思哦，它就是模块而已。
	· admin只是应用的一个“管理入口”而已，一般的有了管理入口的应用才能算是一个完整的应用，所以admin这个模块是必须要有的。
	· 前台后台并不是相互独立的两个应用，虽然我们常常独立开发它们，搞得它们像是两个独立的应用一样，但实际上对于前台后台的区分只是我们习惯上的（tp以前称之为“分组”，先改为模块了），事实上本不应该存在这个分别，不论何时我们所能看到的只有整个应用。
	· 项目所有文件夹都采用小写，除了项目公共目录 。
	· 项目所有文件名都采用小写，除了Controller，Model（但没遵循大小写驼峰规范，规范越多自由越少）。
	· 规范越多自由越少，那myphp为什么要那么多的规范呢？ 首先myphp的规范并不多，好么！无规矩不成方圆，我这么说你懂了吗？
	· 规范多了，自由肯定少了，但myphp想要在尽量少的规范下“定制方圆”，笨蛋，懂了吗？
	· 普通类库和函数库文件：从项目公共，应用公共，任意应用模块下，系统
	· model，Controller类：从项目公共，应用公共，任意应用模块下
	· 主站有特殊性，项目根目录就是当前应用，它没有应用目录的，其它应用是正常的。
	· 未完待续……2014-5-17 23:25:22
----------------------------------------------------------------------------------------------------


【myphp性能再优化】
原本就算是进程都无法避免的两处IO：
1：应用加载系统启动文件，2：启动文件加载进程/运行时文件（现在运行时文件可不要了）
现在mini_index的出现使得减少一次IO成为了可能，那就是将入口文件和系统启动文件结合编译一下就OK了，这样太爽了，省去了一次IO，还压缩了代码哈，内存消耗，和耗时瞬间减小为原来的96%左右了哈（可见IO对运行性能的影响有多大）。这算是一个不小的性能提升了啊哈。
至于另外一次IO是不可能避免的，因为无论怎样你总得要进程来运行吧。
ps：其实还有一个IO，只是应该是算不上的，那就是引入编译的模板文件，这发生在控制器中的显示方法时，这个确实不能优化了，你总不能不要视图吧。
ps：我们优化掉的IO带来的性能提升，主要是原因是：少了加载这步，同时很重要的一点就是由于都是mini版的文件，所以也减轻了很大的资源开销。
ps：不要为一个方面的优化做钻牛角尖式努力，因为肯定会有很多的其它小问题就摆在眼前，分清主次，用有限的时间争取到最大的性能优化才是最重要的，这种为了芝麻而放弃西瓜的固执不是偏执！（一般偏执是褒义的，偏执狂可理解为追求极致，完美的替代词。）

   上面我们将应用入口和系统启动合并编译了，减少了一次IO，但这真的是极致了吗？第二步真的就优化不掉吗？怎么不试试再合并个进程文件呢，但要这样的话我们就不再是用单一入口了，musiccfan/login.php就能直接访问了，理论上我们可以将所有的进程都这样与之合并一下，这样就可以直接访问这些文件，而无需走入口了，也就没有那两次IO了，因为此时没有走单一入口，走的是超级入口嘛，哈哈，哈哈，超级入口确实牛，它跟单一入口在同一目录，理论上可以实现全面的超级入口，彻底的抛弃原先的单一入口，但是问题是，超级入口文件太多可能会有文件名冲突问题，命名规范等问题，一般的我们只将常用的，访问较为频繁的做成超级入口就可以了，如首页，login这些可以做吧，不然根目录有太多的文件也不好的。有没有想过做一个“进程池”呢，生成全部超级入口，但这样肯定不能放在根目录，专门放一个进程文件夹目录，然后直接从池文件夹运行，但这样是多么的别扭啊，每一url都要找一个超级进程文件，那这样的话网站岂不是有很多很多个超级进程吗，这样的话整个网站就像是一盘散沙了，网址没有结构和语义，这对用户来说记网址很难的，理解也虐心啊。所以没必要这么做，完全放弃单一入口真的没必要，就将几个频繁的，特殊性的做成超级入口就可以了，如search.php，login.php，reg.php等，其实只要你不嫌麻烦，做个池放send.php还是不错的，send是用户不会关注的url，它只是接受请求处理的，用户不会看到的，将它做成超级进程倒真是不错哈。

   （当然这个好想法并不需要立即在myphp中实现，我们只要知道有这么种办法就好了，我们可以另外的动态的随时的生成这种文件即可。）
   （超级入口（超级进程）真不是盖的，刚试了一下，发现性能（占用内存）较mini版的单一入口提升93.8%，较非mini版单一入口提升94%，超级入口太棒了，哈哈，但别忘了它是myphp进程发展的产物。）
   （超级入口（超级进程）已不再需要appdebug了，它从生成的那一刻起决定了它的价值方向，它天生就是直接“走”进程的，它没有调试，就是走进程的家伙，有调试也用不上，那是老入口定义的，为假，不可能是真，因为，如果是真它也不会诞生啊。(纠错，忘了种情况：为真，但没有进程文件)）
   （请从超级进程的诞生看待它，现在我们对超级进程的理解只停留在优化这一次IO，难道它仅能是这样而已，这样而已！现在它的价值已超出了它诞生时的价值——优化掉最后一次的IO，但真正实现超级进程也不是这么几个字符替换就能做到的，现在只能说，超级进程，这是个很酷的好点子，有时间再去发掘它的潜能。）
· 上面一会说超级入口，一会说超级进程，有点绕的，旧文件而言，它们是一模一样的东西，但是我们还是将他们分开了，呆在进程池中给系统用的是超级进程，呆在外面，能直接访问到的叫超级入口。   


【代码的更新和维护周期是永远】
	事物总在不停的变化，就像没有静止的风一样，而我们更新、优化、维护就是在追这不停奔跑着的风。
	下面从一个实例来说明这事儿。
占位或有特殊作用的位置我们总用特殊的相对冷门（正常情况几乎不会用到）的词来占住位置如：[run] [mini_index] {!!} 等，但实际中也不可能保证我们的词足够“冷门”（并且总有没有考虑到的情况），所以我们只能再次调整我们的词，让它比冷门更冷门，是其能避免正常内容，这听起来似乎是很笨的法子，但却是唯一的解决办法了，由此我们得出一个结论，内容新沉出新，我们就要不停的适应变化（最明显的就是我们的预编译正则格式化规则那儿了），“不断学习和掌握各种新的姿势，学会适应变化的环境”，代码就像我们一样，需要有勇气对自己坚持到底。
    

【设计不能超过三层】
user一层，message一层，send又是一层，真不能再超过三层了，再多了就要想办法解决使其不能超过三层了。（就算你真能写的过去，模板也受不了的，以model为文件夹，act为文件名（user/message_send.html）（进程里user_message_send.php）这个界限已经都超越了，你还能怎么样？）
（现在架构升级了，有模块了，能缓解一下/user/message/send.html 	user/message~send.php 但这还不是终极解决办法，不超过三层你说的算吗？解决n层的方法就是do……n个子方法）


【ACTION与do】
为了可以将进程“细分”，实现我们的按需加载的高性能追求，可以使用user.php这种在入口绑定模块的方式，user.php?mod=message&act=send，但这种方式也有弊端，这样我们要多建一个入口文件了，这样不符合简洁的结构设计，所以我们想出了另一个好办法，那就是index.php?mod=user&act=message&do=send这样我们的ACTION就是act_do（现已优化用"."连接了），这样就可以生成这个进程了，“细分”的开始显露出来了，还没完呢，要知道是没有act_do这个方法在userAction中的哦，所以实例化控制器时我们又处理下，走act这个方法即userAction·message()，然后这个message()中再根据do来调用对应的独立模型send等等，这里要对do进行严格验证的，（不然可能会出现找不到模板的），这个do就像第二个副操作/子操作一样（注意子操作都是不可见的），所属主操作act上，第一次走的是主操作，但却生成了进程user_message_send.php，下次就直接走进程了，事实上我们只是利用了一下这个主操作message而已，ACTION可能不是act，走的方法名与模板名不一致。
（纠错：怎么个过滤法，ACTION已经被定义了好吗，直接指定下模块操作给显示方法就可以了。）

这真是够疯狂的（发生在do存在时），但就在这疯狂中我们已经实现了细分进程（这里确确的说应该是不想message的send,read等都在一起，因为这样违背了进程按需加载的原则，并且我们不可能send和read同时使用吧）我们的K，I等等围绕进程文件的函数，都有一个共同的目标，那就是提高进程的运行性能，按需加载，按需使用，只包含要用到的，不包含用不到的，不多带一个字符，珍惜每一byte的资源，内存，这就是我们永远的追求——不论何时，安全和性能都是myphp要优先考虑的。
理论上子操作可以实现无数层（当然所有子操作都是不可见的），试验中，可能还会遇到一些问题。

（其实完全没有必要把自己搞的这么复杂，约定三层，我们有的选吗，怎么保证，怎么解决，模块就是控制器，原分组升级为模块，原模块升级为控制器，为什么要这么折磨呢？index.php?mod=user&act=message&do=send以后还要出现do……n吗，你到底想怎么样？实际上我们直接index.php?mod=usermessage&act=send不犯法吧，然后再在usermessage·send中指定指定显示模块user中的不就行了吗，这样就是让人觉得不是很爽而已，没有前者用户/消息/发送这样的结构而已，但要实现这样的结构，是要付出代价的。mvc是一种模式，它没有叫我们究竟实际如何去设计，没有人说到底哪种是对的，只能靠我们实际应用中的摸索去探寻，我想说mvc实现真心不容易！）

（上面是myphp架构未升级之前的情况，这种无赖要怪tp坑了我们这么多年，现已升级，原分组->模块，原模块->控制器）
未完待续……2014-5-17 23:43:22


【避免不完整进程】——不论何时进程文件已全面作好准备，时刻迎接挑战，不再需要加载任何文件。
必须保证一个操作中可能用到的所有文件都引到进程当中去，不然则可能出现不完整进程，为什么会出现“可能用到”这种不确定呢，那是因为我们的操作中可能会有条件，一些条件致使可能会在半路退出函数，还有一些可能会造成选择，选择可能会决定是否加载某文件，比如根据有无参数来决定是否加载验证函数，当然我们要避免这种选择，但是半路退出函数却是我们无法避免的，所有这些原因最终将导致一个进程的文件加载不全，而进程只会创建一次，但每次运行的环境却可能不同，这就造成了当某些时候报找不到类，函数等情况了，因为我们的进程是不完整的嘛，要解决这个办法，也很好办，我们可以在选择之前加载好这些文件即可嘛，I()就是专门干这个的。
（一方面我们不希望看到不完整进程，另一方面我们又要防止进程过载哦，总会各种情况阻碍我们的进程，这也是高性能的阻碍。）


【myphp的进程纠结】
我们为myphp的进程做了很多工作，我们是把提高进程的运行性能放在首位了，为了实现这个目的，我们所信奉的“进程不需要加载任何的文件”，这点是我们进程文件的核心之一，它一直指导着进程的发展方向，要做到这点的确很难，但我们通过各种手段还是做到了这点，例如I()，F()，这一切似乎很成功，但现在这个信奉被动摇了：
看实例：一个验证的方法，当参数不存在时就直接退出无需验证，参数存在时就加载系统验证类来验证。

这是一个很简单的实例，但却反应了很多问题，存在选择，可能会出现不完整进程，ok，我们的I()可以很好的解决，只需在最上面调用I()来加载即可，这样生成的进程就算是完整的了，满足了我们的“进程不在需要加载任何文件”但是从另一个方面（进程的另一个核心）来看，我们的进程却不是完美的，“按需加载，不多包含一个字符，不浪费1byte的内存”，当不存在参数时就不需要验证了，但进程却包含了验证的类（作为整个操作来说这似乎并没有错，但站在“选择”的立场，那还真摊上事了，这只能怪进程太苛求了，谁说不是呢，1byte的资源都不能浪费，但这里着实显得太不近人情和蛮横了）（按需加载真的很难，只能把它当做理想去接近它，即使没有选择也会可能会违背按需使用，比如，控制器要加载，但是控制器中的方法我们一般只使用一个啊，但我们控制器是一个整体，这没有办法啊，这是没法避免的，我们只能尽量的将大量的代码写成单独的文件只有这样才能趋与按需使用的原则。）

现在问题赤裸裸地暴露出来了，进程的两个核心尽然相互排挤，有好的方法解决这件事吗，我们能借鉴index.php?mod=user&act=message&do=send这个来“细分”进程吗？显然是不行了，这两个情景是不同的，就算我们为没有参数和有参数个生成了一个进程，但我们怎么运行它们的，或者是说怎么在它们之间做出选择来运行呢？也让do来做选择，但这样验证还有意义吗，我们既然知道do了，那么还验证个毛啊，自己逗自己玩啊。所以这里“细分”进程是行不通的。

要是进程运行也可以加载文件就不会违背第二个核心了，但是也就违背了第一个核心了，既然左右都不行，那就换一个角度想，倘若我们验证类是在进程运行时加载的，那么加载的类文件是没有经过压缩的，IO代价较大，如果是完整进程，虽说包含的验证类可能会用不到，但是如果真要用时，我们准备好的文件却是压缩的，字符量很少的，就算不用时，也不会浪费多大的性能吧，相反在用时会提升性能，而允许动态加载虽说在不用时没有浪费资源，但却在用时损耗性能，所以现在就看你的取舍了。当你这边得到，就会叫你那边失去，没有十全十美的事，这里myphp最终坚持完整进程，选择完整进程会让我们很痛苦，我们总要提前加载可能缺失的文件，显然这样增加工作量，但得失并存，难道这就是我们追求高性能进程的代价，但为了进程运行时的性能，我们只能这么做，除此下策之外，还有更好的办法么？或许会有好的办法呢，要相信美好的事情正在发生……
（随着业务的复杂性，这种纠结将会愈演愈烈！）

如果我们这么纠结那么可能一开始使用myphp开发模式就是个错，直接写一个一个的功能文件不就可以吗，那样性能多高啊，但是你还想再回到那个时代吗？那个不用开发模式的时代，那个每个功能就要写一个文件，甚至每个文件内容都几乎一样，还是那个将所有功能都写在user.php中，你不是从那儿过来的吗，曾经开发模式不是解救你的救星吗？为什么现在，如果你真要纠结这些那么或许一开始就是个错，这边得到那边就会叫你失去，这是大自然一个很基本的道理，你到现在还不明白吗？用开发模式肯定会有性能上的损耗，但同时它的好处也是显而易见的，那就是代码复用度提高了， 遵循了面向对象的开发规范，统一入口，统一架构，规范开发，这带来的好处不就抵了它的缺点了吗，我们谈性能不是整体上的吗？没有开发模式你怎么完成一个统一的大的项目，根本不可能的好不好，所以纵使开发模式百般不好，但它却是唯一的选择，不然你想怎么办，所以一切的纠结本来就是个纠结，那么你就不要再把自己的牢骚强加给纠结了，除非你叫纠结伦，我这么说，你懂了吗？
这事现在可以放下了，以后就不要再提了，再提找打，万物都是相对的，虽然这样，没有最好，只有更好，但我们还是想做到最好，即使不能够，那么就让自己做的更好，追求极致，我要完美，如果不能够，那么也不放弃，也要努力往正确的方向靠近一点，哪怕是一点，一点点，也要坚持，只要你有勇气对自己忠诚到底，那么你能够做到的。
待续……2014-5-17 23:58:21


【模板名不等于真正走的方法名（操作名的时候）ACTION = act_do】
我们知道，模板名及方法名，ACTION，即为模板名，那为什么会出现方法名与模板名不一致的情况呢，因为do，do导致ACTION可能与实际的的方法名不一致（如：ACTION=message_send，当实际走的方法还是message），即会出现方法是有，但模板名是ACTION，此时就有可能出现有方法但没有模板，对于这个问题，控制器里面就应该对do进行严格过滤以避免出现这个问题，也就是说这里可以省略，但是为了提高myphp的容错能力这里还是做个判断吧。不然自定义控制器里面脑残一下岂不是惨了吗，所以这里这么做是有必要的，系统容错能力关系到安全，所以在写每一个字符时都应该想着提高容错能力这事。
（纠错：怎么个过滤法，ACTION已经被定义了好吗，直接指定下模块操作给显示方法就可以了。）
（拼接方法已改为用'.'了，不然方法名不是不能带'_'吗，而现在没这个问题了，因为'.'本来就不可能被用于方法名。所以现在可能出现这样的进程message_send.type1.php）
待续……2014-5-18 0:03:45


【myphp架构动摇了】
如果不像tp3.1一样升级，原分组升级为模块，原模块升级为控制器，规范的用m（模块），c（控制器），(a)操作/方法名
如果不这样做的话，那么整个用户中心将只有一个userAction控制器啊，之前遇到三层在这里就不是问题了，但do（子操作）还是有意义的，不然遇到无数层就没有办法了吗？试想一下，log, reg, info, message, fans, fatie……这些要写在一个控制器里面这是多么可怕的一件事啊，所以必须要改进，升级对原来的设计模式影响不大，进程等概念可以很方便的迁移到新的架构上面来的。

奋战一夜，现已改造完毕！等待测试完毕再来继续完善此文档。待续2014-5-9 7:08:18


【myphp性能统计：】

不走进程		（走运行不生成进程时，即调试打开）	
▧ 消耗内存：0.33984375 MB
:)用时：0.0205039978027 s

不走进程		（走运行，生成进程时）（调试关闭，没有进程）
▧ 消耗内存：0.388610839844 MB
:)用时：0.225841999054 s

不走进程		（走运行，生成进程和超级进程时）（调试关闭，没有进程）
▧ 消耗内存：0.397888183594 MB
:) 用时：0.331377029419 s

走进程	（非mini版入口）（调试关闭，有进程）
▧ 消耗内存：0.245300292969 MB
:) 用时：0.00578117370605 s

走进程	（mini版入口）（调试关闭，有进程）
▧ 消耗内存：0.233642578125 MB
:)用时：0.0040910243988 s

走超级进程	（调试关闭，有进程）（它不需要调试了）
▧ 消耗内存：0.0146255493164 MB
:)用时：0.0170271396637 s
#没有特殊指明外，以上均为mini版单一入口上的测试。
===============================================================


【myphp性能·按需使用】~我们追求的是极致！
每多加载一个文件，多包涵一个字符，内存占用就会多一点，所以“按需使用”真的很重要，但这又是不容易做到的，就像MVC一样，它只给你一个灯塔，其它的就靠水手自己了，我们就像这水手一样只能在不断地尝试摸索，并根据经验来做出我们认为最优的选择。（这没有什么约定俗成，一劳永逸的万能规则，哈哈这就跟炒菜的哲学是一样的，炒一盘菜这很容易，但是要炒得色香味俱全，那就不容易了，除了对火候恰当的掌控，和对调料比例的斟酌，判断外还有个人经验等等。所以最优并不是很容易做到，但是总要努力往正确的方向靠近一点，哪怕是一点点，不是么？）每当面临这种抉择时请在心里面把这句话默念一面，相信你总能做出最优的选择。


（目前为止我们还没有配置文件，只要系统还不是很复杂就应该用不上配置文件吧，等以后做完善了可能会使用配置文件。）

* myphp的灵活无节操，无下限使得“跨”的成本太低了，但是这却有有一个问题，那就是当文件在myphp面前可以这么灵活的被调用时，我们得防止类名重名等等诸如此类的事情，所以这时就需要用陈长的命名规范了，如：user_indexController，你可以不这么写，那你就等着出错吧，这确实很搞人，但是在没有使用命名规范时，这又是没办法的事情，这就是你要为你的灵活所要付出的代价，所以嫌命名太长的话那就果断用命名空间吧。


【myphp：性能问题究竟被什么所影响】
对程序而言，性能是一个广义的，可能受编码效率，资源开销，程序结构，架构等等数不清的可能所影响着，所以追求性能不是容易的，但也不是不可能，目前所能见到的，最具代表性的，典型的，就是myphp的两个核心思想了，第一：进程不需要加载任何的文件，用进程来消灭IO，请特别注意（这很重要)：这里不仅仅只是消除IO，更是压缩了代码，减小IO的开销,资源消耗；第二：按需使用，不浪费一byte的资源，虽然两个核心会有冲突，但是我们还是觉得核心一不能有任何的动摇，核心二要努力做到；我们发现这两个问题，目前对性能的影响较为突出和典型，超级入口与mini版的入口就在于少了一次IO和全部是压缩的代码，而mini有一次IO和一处没有被压缩，后者的性能（内存占用）竟然差不多是前者的十倍，所以这个优化还是很惊人的，而如果不走进程则内存占用是超级入口的24倍之多，这是一个什么样的概念啊，所以影响性能很大的两点就是IO，和按需使用，或许还没有说的太明白，IO就是各种文件加载，按需使用，你可以看下进程，里面连一个程序之外的字符都不会有的，而要是没进程，我们手写的代码文件会被IO进来解析的，想一下我们的代码注释部分在此时有用吗，没用，但是它现在被加载进来了，IO发生了吧，虽说php解析时会忽略这部分，但是我们完全没必要增加php额外的负担对不，php是解析型语言，只有在运行时才会解析我们的代码，并且每次都是这样，所以这就是为什么解析型语言比C，JAVA这种编译型语言运行性能低的原因了，但这也造就了它的优势，开发快，无需编译，直接修改就能立即得到更改后的效果，php解释型先天缺陷这我们无法改变，但是为它做点什么还是可以的，比如那个进程文件像不像是一次“编译”呢，因为php在解析之前肯定也是会有这么样的一个过程，不是么，而现在我们已经做了，并缓存成进程文件，所以这就好像是一次预编译一样，我想超级进程性能提升肯定和这有很大的关系。总之进程概念是myphp最值得称赞的骄傲。但是做到进程真的不容易，但我们会努力往正确的方向一点一点靠近的。
（我们坚持核心一不能有任何的动摇，那么为什么即使是超级进程还要加载模板文件呢，为什么不把这最后一个IO优化掉呢，你不是说提前加载总比用到时加载为压缩的要好吗，你这样不是耍流氓吗？模板就算是在用时加载的那也是压缩过的好不好（还有如果你真要印模板进来，请告诉我怎么做到呢，输出缓冲？你办不到的好不好，再者说了，模板如果真能写死到进程中去那也是麻烦事，为嘛，进程一般是功能业务逻辑性的，一旦确定就很少变动了，而模板改动的频率比这个大多了好不好，所以模板就让它自己加载吧，它不算我们所要考虑优化掉的IO），它不像普通代码文件啊，而且都是方法的最后一步，这意味着先天的就存在很多可能性让显示方法没有执行，没有执行到最后去，所以特殊情况要特殊看待，还有虽然我们的承认我们每次都比较偏袒核心1，进程就是要包含可能要用到的所有文件，确保运行时不会加载任何的文件，也没有能力加载，我们压根就没有给它这个机会，但偏袒并不意味我们就那么的死心眼，总有特殊情况嘛，再说了，很早之前我们就没把引入模板这步看做是IO，因为这是理所当然的嘛，如果你非要这么苛求非要说这也是一个IO要去掉，那你就干吧，但我想说的是，不要为了芝麻丢了西瓜，与其在这里钻牛角尖最后就算成功了可能也换取不了多大的性能提升，还不如换个方向优化，可能会有更大的提升空间等待发掘呢，既然早就知道优化更新使用永无止境的，那为何不把有限的时间投入到更有意义的事情中去呢？）

以前我们总偏向于核心一，坚持核心一不能有任何的动摇，认为这样才是最好的选择，而现在这观点似乎要被彻底击破了，先来看实例：
留言版要一个过滤列表，以保证过滤非法言论，那这肯定是一个非常大的非法关键字列表了，总共可能有几兆呢，所以难道进程要全部加载进来吗？即使有很大的可能性要走到过滤这步来，也还是不能把它包含到进程中吧，不然，试想一下，这个进程任何时候就会耗大量的资源了，虽说运行时加载的列表可能不是压缩的，但此时“严格按需”加载的优势又体现在什么地方呢？在这么个巨大的文件前面，你还能说直接加载压缩的，比有可能加载不压缩的性能高吗？显然我们承受不了这个代价的，我们此时信奉的进程不在加载任何的文件显然受到了挑战。此时恐怕我们不能再偏袒核心一了，所以嘛，事情从来没有绝对的，对的反面是错，好的反面是坏，我们总是隔着它和自己捉迷藏，这样到头来我们只不过是在追自己的影子而已。咯咯扯远了，总之对于性能，按需加载，进程，我们不敢绝对的说谁对谁错，我们只是踮起脚尖，努力地看清正确的方向，不断接近正确而已。所以所有的纠结其实没必要，这就跟炒菜是一样的，跟着感觉走，总会找到平衡点的。这么简单的道理，就像你每天都要吃饭喝水一样自然，现在你明白了吗？


【myphp应用入口性能最低】
我们看到的事实就是这样：
http://127.0.0.1/mycms/index.php?m=u&a=login
http://127.0.0.1/mycms/u/index.php?a=login
http://127.0.0.1/mycms/login.php
http://127.0.0.1/mycms/u/login.php
后两者几乎没有什么区别，但前两者就比较明显了，这是很明显的，应用入口要多个路由m操作嘛

【单一入口，但并不是唯一的】
前面我们已经说过“只要确定了项目目录，那么所有目录也就随之确定，只要入口遵循我们的定义规范，那么就可以有任意个入口，放在任意目录了，这就是对单一入口，但不是唯一的最好证明了”。
现在我们再来做一个较深一点的探讨：将入口分类

应用单一入口：musiccfan/index.php 	musiccfan/bbs/index.php
· 这是直接放在应用目录下（主站特殊）的入口，它可以访问当前应用的任意模块，任意模块下的进程，总之它有管理整个应用的能力。
· 它就像一个母入口一样，任何时候只要它还在，那么你就能畅通无阻的访问整个应用。
· 应用单一入口可以生成任意进程，任意超级入口，任意超级进程，而模块入口只能生产本模块的进程，因为它的m被绑定死了嘛，它也就只能访问本模块的进程了，所以说嘛，应用入口是进程之母的呐。

应用入口可以作为一个应用的唯一入口，但性能说单一入口，但并不是唯一的，下面绑定模块的入口就是来证明。

---------------------------------------------------------------------------------------
应用·模块入口：musiccfan/user.php 	musiccfan/user/index.php

· 一般它可以放在两个地方，应用文件夹，和应用/模块，两者的功能几乎一样，只有一点不一样的；前者在应用目录下面以模块名命名，后者在放在模块目录下面，以index.php为文件名，除此之外，两种入口的内容是一模一样的。

可以看到他们本质都是入口，但是有的绑定了确定的模块而已，所以就少了一个路由m的操作嘛。

同理我们不仅可以绑定m，还可以绑定，c，a，超级入口就是绑定了m，c，a的。

（note：入口是和url息息相关的（这也与项目部署·架构密切相连），一个完整的url包含这几部分：域名，入口，参数，其中参数又可分为路由m，c，a部分和普通参数部分）
（note：可以这样理解，应用入口是一个统一的入口，单一入口，但并不是应用的唯一入口）
待续2014-5-18 2:48:23


【再说一次，myphp不是框架】
myphp开始逐步完善，越来越框架了，但它始终不断的提醒自己，它的本质是什么，也许有一天myphp成为了“框架”，但它也不会承认的，它不会忘记自己的初衷，不会不明白自己意义的，如果它真成为了框架，那么那将是它死亡的时候。
现在正面回答一下为什么myphp这么抵触框架？
Q：不是抵触，是非常抵触，知道myphp是怎么来的吗？为了改变框架的现状，为了自由的理想，为了……，只是因为有一颗善良的心，myphp就这么发芽了，所以不要在它面前提框架，更不要叫它框架，它会很生气的，谁会忍心呢。
OK，以后不要在提起这个问题了。


【良好的编码习惯】
· 不要轻易地删除更新的代码段，即使现在没用，但可能具有参考意义或能提示先前的问题，以便今后注意，所以对于这样的代码最好的做法是块注释，并写上说明，作好记录，而不是直接删除它。（最正确的决定就是不会让你在将来的某一天后悔的决定）
· 对于业务较强，关联性较强的代码文件最好写上更新时间，并写上详细的说明，以确保今后的维护成本不会很高。
待续2014-5-14 17:34:30……


【idea！】
刚想到一个超级好点子，无论怎样我们总要加载控制器，模型类，即使将进程细分了，message C 但消息控制器中的很多方法我们不会同时使用对不，但是它们已经包含在同一个控制器，同一个文件中去了，所以我们无法地避免包含了我们用不到的这些方法，真正的按需加载真的做不到，只能是理想而已，但是就在刚刚，突然想到一个点子，这或许能让梦想照进现实。我们可以使用:
//[act_no]
……
//[/act_no]
将当前方法用不到的方法括起来，然后在生成进程时去掉这部分不就ok了吗，这样即使我们控制器中写的非常的臃肿，而进程却能够做到按需加载不是么，真正的按需加载，梦想照进现实，不是么。
这个方法真是太赞了，但唯一的代价就是你不得不去把不用的部分都都括起来，这可能很麻烦，但想想只要你能把它括起来，就能把它在进程中去除，是不是有点小激动呢，所以这点代价还是值得的，但要是能就这个思路想出更好，更行之有效的方法那就更好了哈。
这也反应了一个道理，当你极力去实现，证明某事时，另一个反面也被证明，或者说当你认为可以做到最好时，却没想要付出的成本和产生的价值一样高，这使得你不得不去重新思考这样做到底值不值得，用能量守恒定律来解释就是“若要制造永动机，那么它的代价几乎就是它产生的价值”所以你得考虑以这样的方式去实现这样极致，到底值不值得呢？
进程一路走来这么复杂，我甚至于开始怀疑它的价值和意义了，是啊，这样值得吗，真的有性能提升吗，不加载一个文件，按需加载，它容易吗？
纠结，它快不认识自己了，不知道自己是谁了……
如果真要这么做那么如果控制器中有n个方法，我们最多可能在每个方法前后写n-1个这要的括号，总共要写n*(n-1)个括号，括起来的话还要乘以2，而如果是跨控制器的话，那么此办法就不能用于其它控制器了，它只能用于当前控制器，因为这个限定括号是以当前走的方法名为限定过滤词的。
待续……2014-5-18 0:39:37


【myphp的思考】
登陆模块现已全部用它的开发模式改造完毕，我们确实体会到了开发模式的便捷，参数验证，自动过滤，单一入口，超级入口，现在才刚刚开始呢，myphp还有很长的路要走呢，到目前为止myphp的精力几乎全部花在进程IO，上面去了，没有实战一切都是纸上谈兵罢了，现在才刚刚上场呢，或许接下来的实战经历会让它有一个新的认识，无论是对自己还是php身，或许它会发现以前所做的努力其实是那么的可笑，又或许会为之前超前的眼界和理念点32个赞呢，还是被之前的坚持所感动……
OK，继续吧，一切都会被时间来证明的。

myphp或许还有很多不足甚至不合理的设计，但是总的用实例去证明它，在实践的过程中去认识不足，所以你管你现在在怎么的纠结，先埋头按照它做功能，相信在做的过程中会有答案和收获的。
待续……2014-5-21 16:51:18


【myphp的一些名词】
· 总控：系统的控制器 Controller，主控：一般继承总控（也可以不继承，当不用显示模板是就不需要继承总控），当前路由选择的控制器如：indexController，为什么说是主控呢，因为它还可能调用其他控制器。
待续……2014-5-18 21:33:12


【myphp友好智能路由机制】
总有一些情况会导致路由参数错误，但是我们系统是不能允许出错的，并且，当系统决定作出行动时应该是智能的，而不是无论什么情况眉毛胡子一把抓，不管三七二十一来了就跳转，跳还是不跳，怎么跳，怎么才能符合当前情景，怎么才能作出最人性化的决定，这就是友好路由机制所要做的。
用一句话来说就是：模块找不到向上往应用入口，控制器找不到向上往模块，操作找不到向上往控制器，并保证url简洁性
但真正做到友好智能是要考虑很多事的。
· 跳转是在警醒用户，正确的选择应该是什么，不然单纯地系统容错会很别扭的（url与实际系统运行的不对应），这样用户看不出来究竟是出了什么问题，会造成误解，虐心啊！

· 事实上跳转一个很大的意义就只在于警示用户（这点上很多人都没有做的很好，连新浪微博都没有进行跳而是直接容错显示正确的，当然他这样可能是减少请求才这样做，但其实容错跳转其实没有资源的请求的，并且我认为相对于请求资源警示用户才是最重要的），什么才是对的，不然我们直接容错显示正确的视图给用户给用户不就可以吗？但是关键在于我们想要“教育”用户，想要告诉用户什么才是对的，我们想培养用户，我们不想看见一个错误的url但显示的却是一个不相干正确的视图内容，这会让人感到很别扭，让人抓狂。

· 当我们决定要跳转时应该考虑到url的简洁性，简洁的同时还要保证url的结构性，语义性（这些无论在什么时候都要必须做到的），可以从这些地方来做：当有绑定和默认的时候要去除这种无用参数，这种精简并不会对用户造成url认知误区，绑定了的，很好理解，加了也没有任何作用，而默认的就是默认的，没有不就是默认的嘛，index，home用户也很容易理解的，不就这两个嘛。

· url是用户能够看到，主观感受到的，用户会对它进行自己的理解辨识和认知，直观简洁的url不仅利于记忆更是方便用户进行操作，如果设计不合理，那真是虐心啊，并且url的语义性和结构性不仅仅是体现在这里，更重要的是还体现在程序整体结构上，所以url它是如此的重要。（它同整个项目的架构密不可分）

· 至于参数错误，我们直接跳到正确的默认参数，这也很人性化啊，而不是直接报给用户“参数错误，接口错误，权限限制”等容错提示，对于普通用户来说这有个毛用啊，吓他啊，系统有容错，跳转不行吗，跳到正确的地址还有非常好的警醒教导作用，让他知道正确的地址是什么，而报个错这有个毛的用啊，这是调试时给自己看的好不好，这就好像顶级域名302一样，将定义域名302到www的二级域名，这样就像是在暗示用户说这个www的才是正确的主站哦，这样下次用户不就知道了吗，用户认知度就是这样培养起来的嘛？

· 总之一切都是在围绕着用户，所以无论什么时候，在做什么时首先应该想到这对用户意味着什么，能帮助到用户吗？或者对于用户来说有什么问题，当你想好了这些问题之后那么做出来的东西才是用户真正想要的，才是真正完美的东西否则那就是再好也是垃圾。

（路由，这个词说得好像挺牛X的一样感觉，但其实在这里（网站中）只是想表达：沿着什么路到什么地方去这个意思而已。）
（url不是路由，它只是路由的一种体现形式而已。）
（“细节强迫症”意味着你可能要考虑每一个细节，当你想展示一个404页面时你要想想给这个404页面让用户看有什么价值，这对用户来说有什么意义呢。不论什么事，总要从多个方面去思考它的意义，细节是无边无界的，追求完美，自始至终。）
（对于不存在的页面文件可以使用404，这才是真的404，而对于错误的参数问题我们应该引导才对，而不是不负责任的做出决定。）
（真正的404页面是服务器自己提供的，并不是程序控制的，这严格来说与程序无关，程序中出现的任何“404”都应该由程序自己解释清楚这是什么原因，而不是抛个404就能了事的。）
待续……2014-7-22 10:35:29


【myphp使用问题，更新等 ~ 持续更新】
note：如果发现某些问题只在走进程才会出现，那么你可能该怀疑的不是你的代码了而是进程出了问题，进程肯定和我们的运行时代码有点不一样，造成这种情况只有一个原因，那就是编译进程时有问题，有时候少一个空格都会引起各种各样的问题，所以这个问题还是很不容易发现的，当出现这样的情况时首先去看进程到底哪里不一样，然后找编译细节，找到了编译问题也就解决了进程错误问题。

note：刚突然发现在某种情况下页面运行得非常的慢，这么慢不是myphp的风格啊，于是寻找原因发现每次生成进程是非常消耗资源的，而走进程也不会到这个地步的啊，最后发现之所以这么慢是因为出现了交叉进程，在登陆记录页面，有两个进程，index.php是关闭调试的，要生成进程，而u.php调试却是打开的，要删除进程，所以二者就出现了交叉进程（生成进程本来就有不小的资源消耗，现在有来个删除），所以此时出现冲突，对系统的性能是有极大的影响的。所以要尽量避免这种情况的发生，当然最重要的还是要防范于未然，加个文件锁行吗？有时间在做，现在先注意到这个问题就行。（这也说明了一点：不要轻易打开调试，一般上线后几乎不会在线上版本打开调试了，本地调试为了方便——进程改动要不断地去删太麻烦，性能那就无所谓了。）（事实上走调试模式对性能的影响也不是很大的，但生成进程时的性能影响还是比较明显的——“生成文件对磁盘IO是个大消耗，并且字串正则过滤等处理也是一笔不小的开销”，以前对于各种情况还做过统计的嘛）
待续……2014-5-22 16:38:14

note：当我们发现把消息模块的没个功能都改写成Sreve后发现这根以前的没个文件没什么区别，唯一的一点不同就是减少了一些重复代码而已，难道就这样而已，模型有体现在哪儿呢？
待续……2014-5-28 16:34:45

note：虽然我们不喜欢英文，但是对于一些系统提示最好是用英文，因为编码，一般浏览器默认编码为gb2312，而我们的脚本都是utf8编码的，所以用中文会乱码，要是指定编码就不会出现这个问题了，但是得发送一段指定编码的串，这又让人不爽，所以现在规定，在没特殊要求的情况下都统一用英文做输出串吧。
待续……2014-5-25 0:01:45

note：myphp到现在为止还几乎没有做任何数据库层面的工作，目前就先用最原始的方法吧，等有时间再做db吧。
note：myphp的架构可能又要有小的改变或是升级吧，现在感觉控制器好像有点不适应了，根据路由运行的控制器可能是有不同的作用的，用户直接访问的一般都是主要显示视图的，而有一些则是为了实现具体某功能的，如消息ajax发送等处理，明显有很多这样的路由请求目的不是为了显示视图的，而是实现具体某功能的，所以鉴于此情况，原先的控制器可能不能很好的处理这种关系，接下来的一段时间里我们可能要尝试做一些改变了。

note：代码压缩杀伤力太大了，这使得我们可能会遇到一些问题，比如我们想使用空格时可能要考虑到这是否保险呢？详情请参考以前对压缩正则的说明。

note：myphp新增E()函数，错误函数，要知道exit并不是代表错误哦，这只是结束脚本而已，事实上这也并未结束脚本，so，析构还要继续执行的，而我们的E()就是专门说明出错的。虽然它也是通过exit来抛出的，但是，请注意但是，它有一个错误标示，在析构中我们就知道是否这是出错了的情况。

note：没个应用有多套模板，但是没个模块只有一套模板，这样可不灵活呢，5sing用户中心模块有多套模板的，所以现在新增每个模块下面可选多套模板。我们是做出来这种结构，但是在了解DZ，wordpress更换模板主题原理之前我们现在这样没有任何的意义，我们是直接写死的，暂时实现不了更换，除非改代码也叫更换的话。（我们发现无论什么情况，模板和模板编译部署都是对应的。）

待续……2014-5-31 1:16:22



【myphp规范和一些需要注意的问题】
规范是为了更好的编码，规范不是一下子就能说完的，更不是一下子就能做到的，从现在其就开始慢慢养成吧。
1：先来一个tp的规范，通常以单下划线打头的是私有属性或私有方法。

2：不论在怎样，每个模块下index控制器和每个控制器下面index操作总是要有的吧，这是很自然的事情，但这个规则很重要。（如果没有默认index，那就可能出现无限循环重定向，那就玩完了哈。）

3：超级入口/超级进程一般生成了就不能随意删除了，否则用户直接访问这个文件将会404，如果真的撤下了超级入口/超级进程，那么也应该立即也撤下这个网址，换成单一入口的形式，这样就没问题了，经常我们如果进程有变动的话，那么应当也立即更新超级入口/超级进程，并且在极短的时间内完成这件事，升级期间请还是像前面一样撤下这个网址，除非升级时间非常短并且网站流量不在高峰期时才不用这么做的。

4：类名尽管我们可能现在不规范（事实上我们也不打算遵守大小驼峰这种规范，规范太多有时很不爽的），但是我们还是要保证系统结构的规范性，我们类名必须和对应的类文件一致，包括名称大小写上的一致。这就是myphp的规范，简单直白，高效，稳定，可靠。（这种命名规范是基本规范，是必须的，就像语法一样，必须的遵守，否则一定出错。）

5：再说一遍不要出现交叉进程（调试开关并行）这就像是让自己的左右手打架一样，都疼。

6：通常系统错误是开发中出现的错误（这不是bug，开发调试中难免出错），我们不允许因用户操作而出现错误，如果这样的话那么就是网站的bug了，总之不管什么错误我们应该都能够控制住它。

7：细节真的很重要，刚刚我发现mini入口字符数量统计尽然不正确，统计比实际要多一个字符，琢磨了好多次都找不到原因，写得没错啊，为什么多统计一个字符呢，究竟什么原因呢，突然的灵光一闪，我不是改了调试了，false改为true当然少一个字符了，哈哈，细节强迫症啊。

8：很不幸，mycms又要加一个“规矩”了，border-bottom: 1px solid rgb(170, 52, 71);只能这要写，你不能这样写border-bottom:rgb(170, 52, 71) 1px solid;因为这样出来的压缩结果就是border-bottom:rgb(170, 52, 71)1px solid;这在ie10中都有问题，而我们又不想为这个右括号做点什么，所以最好的办法就是再次妥协，的确我们被妥协得够多了，但是这却是最好的办法了，想要实现完美极致压缩就必须这样做，所以现在我们必须有这样的规定，凡是参css属性有这样的括号的，为了保险起见都应该写在最后，否则出问题别说没有提醒你。

9：myphp模板编译时可以极致压缩代码，那么js可能和之前的写法也有所不同了（节点问题），这个需要注意下，不用再为这个兼容性担心了，压缩的代码没有这个问题。（另外我们的代码压缩了，所以会有一些规范或者规定，比如css的写法，空格等，这些我们都有说明的，稍微注意下就好。）

10：对于我们系统来说有进程，文件加载机制，但是对于外来的扩展如phpmailer这样的类来说，我们没有办法照护到它的，他自己有自己的加载方式，所以对于这样的例子我们只有在进程中不考虑它，只能用php原生的方式去加载它，所以我们有时在进程中看到的文件加载列表只是经过我们系统加载的文件而已，事实上可能有运行过程中的文件加载过来，所以我们说进程不在加载任何文件在此时不成立了。这是对于我们可控的系统来说的，对于外来扩展我们是不可控的，所以只能这样了。

11：由于路由的特性，所以不可能出现act.0.html这个要注意了。

12：explode(' '.'/'.' ', $a);这样做的目的是因为explode(' / ', $a);不能通过进程压缩的危险——保不住空格，所以这里只能这样了，或者自己定义截取变量吧$g = ' '.'/'.' ';

13：$this->assign('title', '我饿了5el.me - 爱生活，爱简单！');title中经常使用到' - '但是这个在做进程时，却会被过滤掉空格，虽然只是一个空格的问题，但这也是不能接受的，这和上面的问题是一样的，所以此时只能这么做了'&nbsp;-&nbsp;'，虽然有点麻烦，但这是最简单有效的最好办法了。

14：请严格遵循大小写，为了兼容Linux，目录大小写必须严格。

15：很多时候我们要将一维数组变成二维数组来进行操作使用，例如遍历，但是遍历前我们需要检测数组是否为真，如果是这样判断 if ($arr) 那么是错误的，这里会漏判段这种情况：array(array())，这个判断的结果为真的哦，显然这样遍历是要出问题的，那是什么原因导致会出现array(array())的呢，我们db.class在没有结果时都不会返回这样的结果的啊，原因是因为 is_array($result[0]) ? $arr = $result : $arr[] = $result; 这样我们就自然的将原本的 array()变成了array(array())，于是就出问题了，要解决这个问题也很简单，这就需要我们在判断前这样判断即可：if ($arr[0]) 这样就ok了。

· 发现个问题，在调试模式下，如果按住强制刷新，有时会出现某种文件读写错误，这可能是个bug，直接影响到程序的健壮性，因为这可能在大并发（高请求）时出现问题，目前尚不知是什么原因，没有错误日志，那个出错信息也太快了，看不清楚（当然查php日志可能有答案，但是有点麻烦吧），可以肯定的是，这个出错可能是调试时文件读写来不及反应而引发的系列问题而导致的，或者是文件读写锁的问题，总之这个错误是程序在做文件操作时没有考虑高请求（快请求）时产生的意外情况。
ps：那个bug的原因找到了，functions的736行，删除模板编译文件是出错了啊，看来真是文件操作太快，出现读写问题啊。是不是没有锁呢，总之原因找到了，这属于文件操作行为的问题，系统设计没有缺陷，以后涉及到文件操作时在修复此bug。
待续……2014-11-7 22:07:02

【myphp控制器升级之路】
随着一般视图控制器（访问控制器）与功能控制器的逐渐渐远，退出功能控制器是必然的，tp的控制器设计并不适用于我们的，只能供我们借鉴而已。我们的设计是专用于我们特定的情况的。在消息模块的开发中我们发现明显有一部分操作是不需要视图的，它们也要通过路由访问，但是他们不是给普通用户看的，他们被用于ajax请求，对应的是诸如发消息，收消息等功能，显然这和tp的控制器设计不一样，因为我们问题的诉求根本就不一样，所以我们必须基于我们的问题来看待这件事了，我们的问题是怎样这两种不同的操作分开来呢，即一种是访问主要是为了显示视图给用户看，一种主要是在执行某功能。（可能我们目前最大的诉求就是这两者的区别现在在一个控制器中体现出来了，我们不能或很难去兼顾它们，怎样去解决这个问题呢？或者难道是有视图显示没有视图显示的区别？又或者我们是想要一种让用户访问的普通操作和我们的具有功能的操作呢，难道不要这种区分，合二为一？纠结！）
	当然问题提出来了，我们或许没有什么好的解决办法，因为我们还在不断地摸索过程中嘛。
可能我们会这样做建一个mesage2来做那个主要是执行功能的控制器。实际上一个控制器也可能完成这两件事，只要对访问进行区分就可以了（zhiphp就是这么干的，一个操作即显示视图，同时又接受参数请求执行功能），但是这样总归不太好，又太复杂，不利于我们做进程。

	合二为一太复杂才导致我们不这样做的，事实上有的情况可以这么考虑的，如login，此时这个显示也太简单了吧，空方法体都可以，因为就一个自动显示模板即可嘛，所以这种情况下还是可以考虑的。

还会有更好的办法吗？

我们发现我们只是想将显示视图和不显示视图分开，如果只是这样就做一种控制器那么就不值得了。所以目前无需做分层控制器。

待续……2014-6-9 12:45:40

                             _   _            
   _______________          |*\_/*|________   
  |  ___________  |        ||_/-\_|______  |  
  | |           | |        | |           | |  
  | |   0   0   | |        | |   0   0   | |  
  | |     -     | |        | |     -     | |  
  | |   \___/   | |        | |   \___/   | |  
  | |___     ___| |        | |___________| |  
  |_____|\_/|_____|        |_______________|  
    _|__|/ \|_|_.............._|________|_    
   / ********** \            / ********** \   
 /  ************  \        /  ************  \ 
--------------------      --------------------
到现在 过去了的就是过去了的 你都不在乎 你懂或者不懂又能怎么样呢 反正都已经这样了

或许所有都不在重要了 现在是新的开始 全新的开始 因为baby 你说改变也是件美好的事

baby 好好照顾好自己 :)

2015-4-25 09:37:19






不能定义public和data名的模块 不能定义public名的控制器和static的方法名




=======================================================================================
开发规范
	虽然我们很讨厌条条框框 但是规范的好处是显而易见的 你会喜欢它的

小驼峰法
	变量一般用小驼峰法标识。驼峰法的意思是：除第一个单词之外，其他单词首字母大写。譬如
	int myStudentCount;
	变量myStudentCount第一个单词是全部小写，后面的单词首字母大写。
大驼峰法
	相比小驼峰法，大驼峰法把第一个单词的首字母也大写了。常用于类名，函数名，属性，命名空间。譬如
	public class DataBaseUser;









=======================================================================================
日志功能 & 页面跟踪

系统日志的记录是自动进行的
	系统错误、异常信息会自动记录 不论是否在部署模式还是调试模式都会记录
	系统运行信息在调试时会被记录
	任何时候日志信息都可以被强制记录
	页面运行信息trace与日志密切相关 trace信息可以被强制写入日志

trace
	可以记录页面运行过程中的各种信息 可以随意使用 与日志密切相关 记录的信息很可能写入日志

系统的日志的分类

	日志信息必须确保详细

	ERROR 	错误信息        记录各种错误信息
	INFO 	程序运行信息    随意发挥
	DEBUG 	程序调试信息    调试时随意发挥
	SQL 	sql语句         记录执行的SQL

	抛出异常也算是错误 但是异常和错误根本就不是一回事 错误是系统 程序不可预料的 而异常是程序中可控的错误处理机制 所以错误码和异常码也不是一回事 错误码是系统的 异常吗是我们定义的

===========================================================================================

啊哈，有个重要的事情忘说了，myphp改名了，叫做SF了，哈哈，baby I LOVE。

2015-10-31 15:28:46

这个东西写了这么久，也改名了，由myphp文档改为SF-Note了，这本来就不算开发文档，就当做是一种过程或者心得的一种记录吧。
===========================================================================================